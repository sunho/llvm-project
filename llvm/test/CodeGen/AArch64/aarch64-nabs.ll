; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -verify-machineinstrs -mtriple=aarch64-linux-gnu | FileCheck %s
; Check that -std::abs(x) is compiled without generating redundant neg instructions.

define i8 @nabs8(i8 %0) {
; CHECK-LABEL: nabs8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    neg w0, w0
; CHECK-NEXT:    ret
  %2 = sub i8 0, %0
  ret i8 %2
}

define i16 @nabs16(i16 %0) {
; CHECK-LABEL: nabs16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sbfx w8, w0, #15, #1
; CHECK-NEXT:    eor w9, w0, w8
; CHECK-NEXT:    sub w0, w8, w9
; CHECK-NEXT:    ret
  %2 = tail call i16 @llvm.abs.i16(i16 %0, i1 false)
  %3 = sub i16 0, %2
  ret i16 %3
}

define i32 @nabs32(i32 %0) {
; CHECK-LABEL: nabs32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp w0, #0
; CHECK-NEXT:    cneg w0, w0, pl
; CHECK-NEXT:    ret
  %2 = tail call i32 @llvm.abs.i32(i32 %0, i1 true)
  %3 = sub nsw i32 0, %2
  ret i32 %3
}

define i64 @nabs64(i64 %0) {
; CHECK-LABEL: nabs64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp x0, #0
; CHECK-NEXT:    cneg x0, x0, pl
; CHECK-NEXT:    ret
  %2 = tail call i64 @llvm.abs.i64(i64 %0, i1 true)
  %3 = sub nsw i64 0, %2
  ret i64 %3
}

declare i32 @llvm.abs.i32(i32, i1 immarg)
declare i16 @llvm.abs.i16(i16, i1 immarg)
declare i64 @llvm.abs.i64(i64, i1 immarg)
